import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { z } from "zod";
import { 
  insertFreelancerProfileSchema, 
  insertAutomationSettingsSchema,
  insertProposalSchema
} from "@shared/schema";
import { generateProposal } from "./services/openai";
import { searchProjects } from "./services/projectSearch";
import { automationEngine } from "./services/automationEngine";
import { notificationService } from "./services/notificationService";
import { PlatformService } from "./services/platformIntegrations";

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Dashboard stats
  app.get('/api/dashboard/stats', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const stats = await storage.getUserStats(userId);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // Freelancer profile routes
  app.get('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getFreelancerProfile(userId);
      res.json(profile);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  app.post('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profileData = insertFreelancerProfileSchema.parse({
        ...req.body,
        userId
      });
      
      const existingProfile = await storage.getFreelancerProfile(userId);
      
      let profile;
      if (existingProfile) {
        profile = await storage.updateFreelancerProfile(userId, profileData);
      } else {
        profile = await storage.createFreelancerProfile(profileData);
      }
      
      res.json(profile);
    } catch (error) {
      console.error("Error saving profile:", error);
      res.status(500).json({ message: "Failed to save profile" });
    }
  });

  // Proposals routes
  app.get('/api/proposals', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const proposals = await storage.getProposals(userId);
      
      // Get project details for each proposal
      const proposalsWithProjects = await Promise.all(
        proposals.map(async (proposal) => {
          const project = await storage.getProjects();
          const projectDetail = project.find(p => p.id === proposal.projectId);
          return {
            ...proposal,
            project: projectDetail
          };
        })
      );
      
      res.json(proposalsWithProjects);
    } catch (error) {
      console.error("Error fetching proposals:", error);
      res.status(500).json({ message: "Failed to fetch proposals" });
    }
  });

  app.post('/api/proposals/generate', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { projectId, customInstructions } = req.body;
      
      // Get project details
      const projects = await storage.getProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Get user profile for context
      const profile = await storage.getFreelancerProfile(userId);
      
      // Generate proposal using OpenAI
      const proposalContent = await generateProposal(project, profile, customInstructions);
      
      // Save the proposal
      const proposal = await storage.createProposal({
        userId,
        projectId,
        content: proposalContent.content,
        bidAmount: proposalContent.bidAmount,
        proposedTimeline: proposalContent.timeline,
        isAutoGenerated: true,
        status: "pending"
      });
      
      res.json(proposal);
    } catch (error) {
      console.error("Error generating proposal:", error);
      res.status(500).json({ message: "Failed to generate proposal" });
    }
  });

  // Projects routes
  app.get('/api/projects', isAuthenticated, async (req: any, res) => {
    try {
      const { platform, skills, minMatchScore } = req.query;
      
      const filters: any = {};
      if (platform) filters.platform = platform as string;
      if (skills) filters.skills = (skills as string).split(',');
      if (minMatchScore) filters.minMatchScore = parseInt(minMatchScore as string);
      
      const projects = await storage.getProjects(filters);
      res.json(projects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });

  app.post('/api/projects/search', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get user's automation settings and profile
      const settings = await storage.getAutomationSettings(userId);
      const profile = await storage.getFreelancerProfile(userId);
      
      // Search for new projects
      const newProjects = await searchProjects(settings, profile);
      
      // Save new projects to database
      const savedProjects = await Promise.all(
        newProjects.map(project => storage.createProject(project))
      );
      
      res.json(savedProjects);
    } catch (error) {
      console.error("Error searching projects:", error);
      res.status(500).json({ message: "Failed to search projects" });
    }
  });

  // Automation settings routes
  app.get('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settings = await storage.getAutomationSettings(userId);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching automation settings:", error);
      res.status(500).json({ message: "Failed to fetch automation settings" });
    }
  });

  app.post('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settingsData = insertAutomationSettingsSchema.parse({
        ...req.body,
        userId
      });
      
      const existingSettings = await storage.getAutomationSettings(userId);
      
      let settings;
      if (existingSettings) {
        settings = await storage.updateAutomationSettings(userId, settingsData);
      } else {
        settings = await storage.createAutomationSettings(settingsData);
      }
      
      res.json(settings);
    } catch (error) {
      console.error("Error saving automation settings:", error);
      res.status(500).json({ message: "Failed to save automation settings" });
    }
  });

  // Notifications routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notifications = await storage.getNotifications(userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.patch('/api/notifications/:id/read', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.markNotificationRead(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  // Automation routes
  app.get('/api/automation/status', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const status = await automationEngine.getAutomationStatus(userId);
      res.json(status);
    } catch (error) {
      console.error("Error fetching automation status:", error);
      res.status(500).json({ message: "Failed to fetch automation status" });
    }
  });

  app.post('/api/automation/start', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await automationEngine.startAutomation(userId);
      res.json({ message: "Automation started successfully" });
    } catch (error) {
      console.error("Error starting automation:", error);
      res.status(500).json({ message: "Failed to start automation" });
    }
  });

  app.post('/api/automation/stop', isAuthenticated, async (req: any, res) => {
    try {
      await automationEngine.stopAutomation();
      res.json({ message: "Automation stopped successfully" });
    } catch (error) {
      console.error("Error stopping automation:", error);
      res.status(500).json({ message: "Failed to stop automation" });
    }
  });

  app.post('/api/automation/run-manual', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await automationEngine.runManualCycle(userId);
      res.json({ message: "Manual automation cycle completed" });
    } catch (error) {
      console.error("Error running manual automation:", error);
      res.status(500).json({ message: "Failed to run manual automation" });
    }
  });

  // Notification routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 20;
      const notifications = await notificationService.getUserNotifications(userId, limit);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.put('/api/notifications/:id/read', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notificationId = req.params.id;
      await notificationService.markAsRead(notificationId, userId);
      res.json({ message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.put('/api/notifications/read-all', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await notificationService.markAllAsRead(userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  app.get('/api/notifications/unread-count', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await notificationService.getUnreadCount(userId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  // Platform connection routes
  app.get('/api/platform-connections', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const connections = await storage.getPlatformConnections(userId);
      res.json(connections);
    } catch (error) {
      console.error("Error fetching platform connections:", error);
      res.status(500).json({ message: "Failed to fetch platform connections" });
    }
  });

  app.post('/api/platform-connections', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { platform, credentials } = req.body;
      
      const connection = await storage.createPlatformConnection({
        userId,
        platform,
        credentials,
        isActive: true
      });
      
      res.json(connection);
    } catch (error) {
      console.error("Error creating platform connection:", error);
      res.status(500).json({ message: "Failed to create platform connection" });
    }
  });

  app.delete('/api/platform-connections/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const connectionId = req.params.id;
      await storage.deletePlatformConnection(connectionId, userId);
      res.json({ message: "Platform connection deleted" });
    } catch (error) {
      console.error("Error deleting platform connection:", error);
      res.status(500).json({ message: "Failed to delete platform connection" });
    }
  });

  // Analytics routes
  app.get('/api/analytics/overview', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const timeframe = req.query.timeframe as string || '30d';
      const analytics = await storage.getAnalyticsOverview(userId, timeframe);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics overview:", error);
      res.status(500).json({ message: "Failed to fetch analytics overview" });
    }
  });

  app.get('/api/analytics/proposal-performance', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const performance = await storage.getProposalPerformance(userId);
      res.json(performance);
    } catch (error) {
      console.error("Error fetching proposal performance:", error);
      res.status(500).json({ message: "Failed to fetch proposal performance" });
    }
  });

  app.get('/api/analytics/earnings-forecast', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const forecast = await storage.getEarningsForecast(userId);
      res.json(forecast);
    } catch (error) {
      console.error("Error fetching earnings forecast:", error);
      res.status(500).json({ message: "Failed to fetch earnings forecast" });
    }
  });

  // Proposal auto-submission route
  app.post('/api/proposals/:id/submit', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const proposalId = req.params.id;
      
      // Get proposal and project details
      const proposal = await storage.getProposalById(proposalId, userId);
      if (!proposal) {
        return res.status(404).json({ message: "Proposal not found" });
      }
      
      const project = await storage.getProjectById(proposal.projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Submit via platform service
      const platformService = new PlatformService();
      const result = await platformService.submitProposal(project.platform, {
        projectId: project.platformProjectId,
        content: proposal.content,
        bidAmount: Number(proposal.bidAmount),
        timeline: proposal.proposedTimeline || "2-3 weeks"
      });
      
      if (result.success) {
        // Update proposal status
        await storage.updateProposal(proposalId, { sentAt: new Date() });
        
        // Create notification
        await notificationService.createNotification({
          userId,
          title: "Proposal Submitted",
          message: `Successfully submitted proposal for: ${project.title}`,
          type: "proposal_update",
          data: { proposalId, projectId: project.id }
        });
      }
      
      res.json(result);
    } catch (error) {
      console.error("Error submitting proposal:", error);
      res.status(500).json({ message: "Failed to submit proposal" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
