import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { z } from "zod";
import { 
  insertFreelancerProfileSchema, 
  insertAutomationSettingsSchema,
  insertProposalSchema
} from "@shared/schema";
import { generateProposal } from "./services/openai";
import { searchProjects } from "./services/projectSearch";

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Dashboard stats
  app.get('/api/dashboard/stats', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const stats = await storage.getUserStats(userId);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // Freelancer profile routes
  app.get('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getFreelancerProfile(userId);
      res.json(profile);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  app.post('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profileData = insertFreelancerProfileSchema.parse({
        ...req.body,
        userId
      });
      
      const existingProfile = await storage.getFreelancerProfile(userId);
      
      let profile;
      if (existingProfile) {
        profile = await storage.updateFreelancerProfile(userId, profileData);
      } else {
        profile = await storage.createFreelancerProfile(profileData);
      }
      
      res.json(profile);
    } catch (error) {
      console.error("Error saving profile:", error);
      res.status(500).json({ message: "Failed to save profile" });
    }
  });

  // Proposals routes
  app.get('/api/proposals', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const proposals = await storage.getProposals(userId);
      
      // Get project details for each proposal
      const proposalsWithProjects = await Promise.all(
        proposals.map(async (proposal) => {
          const project = await storage.getProjects();
          const projectDetail = project.find(p => p.id === proposal.projectId);
          return {
            ...proposal,
            project: projectDetail
          };
        })
      );
      
      res.json(proposalsWithProjects);
    } catch (error) {
      console.error("Error fetching proposals:", error);
      res.status(500).json({ message: "Failed to fetch proposals" });
    }
  });

  app.post('/api/proposals/generate', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { projectId, customInstructions } = req.body;
      
      // Get project details
      const projects = await storage.getProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Get user profile for context
      const profile = await storage.getFreelancerProfile(userId);
      
      // Generate proposal using OpenAI
      const proposalContent = await generateProposal(project, profile, customInstructions);
      
      // Save the proposal
      const proposal = await storage.createProposal({
        userId,
        projectId,
        content: proposalContent.content,
        bidAmount: proposalContent.bidAmount,
        proposedTimeline: proposalContent.timeline,
        isAutoGenerated: true,
        status: "pending"
      });
      
      res.json(proposal);
    } catch (error) {
      console.error("Error generating proposal:", error);
      res.status(500).json({ message: "Failed to generate proposal" });
    }
  });

  // Projects routes
  app.get('/api/projects', isAuthenticated, async (req: any, res) => {
    try {
      const { platform, skills, minMatchScore } = req.query;
      
      const filters: any = {};
      if (platform) filters.platform = platform as string;
      if (skills) filters.skills = (skills as string).split(',');
      if (minMatchScore) filters.minMatchScore = parseInt(minMatchScore as string);
      
      const projects = await storage.getProjects(filters);
      res.json(projects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });

  app.post('/api/projects/search', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get user's automation settings and profile
      const settings = await storage.getAutomationSettings(userId);
      const profile = await storage.getFreelancerProfile(userId);
      
      // Search for new projects
      const newProjects = await searchProjects(settings, profile);
      
      // Save new projects to database
      const savedProjects = await Promise.all(
        newProjects.map(project => storage.createProject(project))
      );
      
      res.json(savedProjects);
    } catch (error) {
      console.error("Error searching projects:", error);
      res.status(500).json({ message: "Failed to search projects" });
    }
  });

  // Automation settings routes
  app.get('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settings = await storage.getAutomationSettings(userId);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching automation settings:", error);
      res.status(500).json({ message: "Failed to fetch automation settings" });
    }
  });

  app.post('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settingsData = insertAutomationSettingsSchema.parse({
        ...req.body,
        userId
      });
      
      const existingSettings = await storage.getAutomationSettings(userId);
      
      let settings;
      if (existingSettings) {
        settings = await storage.updateAutomationSettings(userId, settingsData);
      } else {
        settings = await storage.createAutomationSettings(settingsData);
      }
      
      res.json(settings);
    } catch (error) {
      console.error("Error saving automation settings:", error);
      res.status(500).json({ message: "Failed to save automation settings" });
    }
  });

  // Notifications routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notifications = await storage.getNotifications(userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.patch('/api/notifications/:id/read', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.markNotificationRead(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
