import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { z } from "zod";
import { 
  insertFreelancerProfileSchema, 
  insertAutomationSettingsSchema,
  insertProposalSchema
} from "@shared/schema";
import { generateProposal } from "./services/openai";
import { searchProjects } from "./services/projectSearch";
import { automationEngine } from "./services/automationEngine";
import { notificationService } from "./services/notificationService";
import { PlatformService } from "./services/platformIntegrations";
import { geminiProjectDiscovery } from "./services/geminiService";
import { proposalTestingService } from "./services/proposalTestingService";
import { emailService } from "./services/emailService";
import { performanceOptimizer } from "./services/performanceOptimizer";

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Dashboard stats
  app.get('/api/dashboard/stats', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const stats = await storage.getUserStats(userId);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // Freelancer profile routes
  app.get('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getFreelancerProfile(userId);
      res.json(profile);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  app.post('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profileData = insertFreelancerProfileSchema.parse({
        ...req.body,
        userId
      });
      
      const existingProfile = await storage.getFreelancerProfile(userId);
      
      let profile;
      if (existingProfile) {
        profile = await storage.updateFreelancerProfile(userId, profileData);
      } else {
        profile = await storage.createFreelancerProfile(profileData);
      }
      
      res.json(profile);
    } catch (error) {
      console.error("Error saving profile:", error);
      res.status(500).json({ message: "Failed to save profile" });
    }
  });

  // Proposals routes
  app.get('/api/proposals', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const proposals = await storage.getProposals(userId);
      
      // Get project details for each proposal
      const proposalsWithProjects = await Promise.all(
        proposals.map(async (proposal) => {
          const project = await storage.getProjects();
          const projectDetail = project.find(p => p.id === proposal.projectId);
          return {
            ...proposal,
            project: projectDetail
          };
        })
      );
      
      res.json(proposalsWithProjects);
    } catch (error) {
      console.error("Error fetching proposals:", error);
      res.status(500).json({ message: "Failed to fetch proposals" });
    }
  });

  app.post('/api/proposals/generate', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { projectId, customInstructions } = req.body;
      
      // Get project details
      const projects = await storage.getProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Get user profile for context
      const profile = await storage.getFreelancerProfile(userId);
      
      // Generate proposal using OpenAI
      const proposalContent = await generateProposal(project, profile, customInstructions);
      
      // Save the proposal
      const proposal = await storage.createProposal({
        userId,
        projectId,
        content: proposalContent.content,
        bidAmount: proposalContent.bidAmount,
        proposedTimeline: proposalContent.timeline,
        isAutoGenerated: true,
        status: "pending"
      });
      
      res.json(proposal);
    } catch (error) {
      console.error("Error generating proposal:", error);
      res.status(500).json({ message: "Failed to generate proposal" });
    }
  });

  // Projects routes
  app.get('/api/projects', isAuthenticated, async (req: any, res) => {
    try {
      const { platform, skills, minMatchScore } = req.query;
      
      const filters: any = {};
      if (platform) filters.platform = platform as string;
      if (skills) filters.skills = (skills as string).split(',');
      if (minMatchScore) filters.minMatchScore = parseInt(minMatchScore as string);
      
      const projects = await storage.getProjects(filters);
      res.json(projects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });

  app.post('/api/projects/search', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get user's automation settings and profile
      const settings = await storage.getAutomationSettings(userId);
      const profile = await storage.getFreelancerProfile(userId);
      
      // Search for new projects
      const newProjects = await searchProjects(settings, profile);
      
      // Save new projects to database
      const savedProjects = await Promise.all(
        newProjects.map(project => storage.createProject(project))
      );
      
      res.json(savedProjects);
    } catch (error) {
      console.error("Error searching projects:", error);
      res.status(500).json({ message: "Failed to search projects" });
    }
  });

  // Automation settings routes
  app.get('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settings = await storage.getAutomationSettings(userId);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching automation settings:", error);
      res.status(500).json({ message: "Failed to fetch automation settings" });
    }
  });

  app.post('/api/automation/settings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settingsData = insertAutomationSettingsSchema.parse({
        ...req.body,
        userId
      });
      
      const existingSettings = await storage.getAutomationSettings(userId);
      
      let settings;
      if (existingSettings) {
        settings = await storage.updateAutomationSettings(userId, settingsData);
      } else {
        settings = await storage.createAutomationSettings(settingsData);
      }
      
      res.json(settings);
    } catch (error) {
      console.error("Error saving automation settings:", error);
      res.status(500).json({ message: "Failed to save automation settings" });
    }
  });

  // Notifications routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notifications = await storage.getNotifications(userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.patch('/api/notifications/:id/read', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.markNotificationRead(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  // Automation routes
  app.get('/api/automation/status', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const status = await automationEngine.getAutomationStatus(userId);
      res.json(status);
    } catch (error) {
      console.error("Error fetching automation status:", error);
      res.status(500).json({ message: "Failed to fetch automation status" });
    }
  });

  app.post('/api/automation/start', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await automationEngine.startAutomation(userId);
      res.json({ message: "Automation started successfully" });
    } catch (error) {
      console.error("Error starting automation:", error);
      res.status(500).json({ message: "Failed to start automation" });
    }
  });

  app.post('/api/automation/stop', isAuthenticated, async (req: any, res) => {
    try {
      await automationEngine.stopAutomation();
      res.json({ message: "Automation stopped successfully" });
    } catch (error) {
      console.error("Error stopping automation:", error);
      res.status(500).json({ message: "Failed to stop automation" });
    }
  });

  app.post('/api/automation/run-manual', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await automationEngine.runManualCycle(userId);
      res.json({ message: "Manual automation cycle completed" });
    } catch (error) {
      console.error("Error running manual automation:", error);
      res.status(500).json({ message: "Failed to run manual automation" });
    }
  });

  // Notification routes
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 20;
      const notifications = await notificationService.getUserNotifications(userId, limit);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.put('/api/notifications/:id/read', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notificationId = req.params.id;
      await notificationService.markAsRead(notificationId, userId);
      res.json({ message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.put('/api/notifications/read-all', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await notificationService.markAllAsRead(userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  app.get('/api/notifications/unread-count', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await notificationService.getUnreadCount(userId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  // Platform connection routes
  app.get('/api/platform-connections', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const connections = await storage.getPlatformConnections(userId);
      res.json(connections);
    } catch (error) {
      console.error("Error fetching platform connections:", error);
      res.status(500).json({ message: "Failed to fetch platform connections" });
    }
  });

  app.post('/api/platform-connections', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { platform, credentials } = req.body;
      
      const connection = await storage.createPlatformConnection({
        userId,
        platform,
        credentials,
        isActive: true
      });
      
      res.json(connection);
    } catch (error) {
      console.error("Error creating platform connection:", error);
      res.status(500).json({ message: "Failed to create platform connection" });
    }
  });

  app.delete('/api/platform-connections/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const connectionId = req.params.id;
      await storage.deletePlatformConnection(connectionId, userId);
      res.json({ message: "Platform connection deleted" });
    } catch (error) {
      console.error("Error deleting platform connection:", error);
      res.status(500).json({ message: "Failed to delete platform connection" });
    }
  });

  // Analytics routes
  app.get('/api/analytics/overview', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const timeframe = req.query.timeframe as string || '30d';
      const analytics = await storage.getAnalyticsOverview(userId, timeframe);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics overview:", error);
      res.status(500).json({ message: "Failed to fetch analytics overview" });
    }
  });

  app.get('/api/analytics/proposal-performance', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const performance = await storage.getProposalPerformance(userId);
      res.json(performance);
    } catch (error) {
      console.error("Error fetching proposal performance:", error);
      res.status(500).json({ message: "Failed to fetch proposal performance" });
    }
  });

  app.get('/api/analytics/earnings-forecast', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const forecast = await storage.getEarningsForecast(userId);
      res.json(forecast);
    } catch (error) {
      console.error("Error fetching earnings forecast:", error);
      res.status(500).json({ message: "Failed to fetch earnings forecast" });
    }
  });

  // Proposal auto-submission route
  app.post('/api/proposals/:id/submit', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const proposalId = req.params.id;
      
      // Get proposal and project details
      const proposal = await storage.getProposalById(proposalId, userId);
      if (!proposal) {
        return res.status(404).json({ message: "Proposal not found" });
      }
      
      const project = await storage.getProjectById(proposal.projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      // Submit via platform service
      const platformService = new PlatformService();
      const result = await platformService.submitProposal(project.platform, {
        projectId: project.platformProjectId,
        content: proposal.content,
        bidAmount: Number(proposal.bidAmount),
        timeline: proposal.proposedTimeline || "2-3 weeks"
      });
      
      if (result.success) {
        // Update proposal status
        await storage.updateProposal(proposalId, { sentAt: new Date() });
        
        // Create notification
        await notificationService.createNotification({
          userId,
          title: "Proposal Submitted",
          message: `Successfully submitted proposal for: ${project.title}`,
          type: "proposal_update",
          data: { proposalId, projectId: project.id }
        });
      }
      
      res.json(result);
    } catch (error) {
      console.error("Error submitting proposal:", error);
      res.status(500).json({ message: "Failed to submit proposal" });
    }
  });

  // Enhanced project discovery with Gemini
  app.post('/api/projects/enhanced-search', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { skills, experience, budget, excludeKeywords } = req.body;
      
      const profile = await storage.getFreelancerProfile(userId);
      const searchCriteria = {
        skills: skills || profile?.skills || [],
        experience: experience || profile?.experience || 'intermediate',
        budget,
        excludeKeywords
      };

      const enhancedMatches = await geminiProjectDiscovery.enhanceProjectDiscovery(profile, searchCriteria);
      res.json(enhancedMatches);
    } catch (error) {
      console.error("Error in enhanced project search:", error);
      res.status(500).json({ message: "Failed to perform enhanced project search" });
    }
  });

  // Get market insights
  app.get('/api/projects/market-insights', isAuthenticated, async (req: any, res) => {
    try {
      const { projectIds } = req.query;
      const ids = projectIds ? projectIds.split(',') : [];
      
      const insights = await geminiProjectDiscovery.generateProjectInsights(ids);
      res.json(insights);
    } catch (error) {
      console.error("Error generating market insights:", error);
      res.status(500).json({ message: "Failed to generate market insights" });
    }
  });

  // Proposal testing routes
  app.get('/api/proposals/test-projects', isAuthenticated, async (req: any, res) => {
    try {
      const { category } = req.query;
      const projects = category 
        ? proposalTestingService.getTestProjectsByCategory(category as string)
        : proposalTestingService.getTestProjects();
      
      res.json(projects);
    } catch (error) {
      console.error("Error fetching test projects:", error);
      res.status(500).json({ message: "Failed to fetch test projects" });
    }
  });

  app.post('/api/proposals/run-tests', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { categories } = req.body;
      
      const profile = await storage.getFreelancerProfile(userId);
      if (!profile) {
        return res.status(400).json({ message: "Profile required for testing" });
      }

      const results = await proposalTestingService.runProposalTests(profile, categories);
      const report = proposalTestingService.generateTestReport(results);
      
      res.json({ results, report });
    } catch (error) {
      console.error("Error running proposal tests:", error);
      res.status(500).json({ message: "Failed to run proposal tests" });
    }
  });

  app.post('/api/proposals/test-specific', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { projectId, customInstructions } = req.body;
      
      const profile = await storage.getFreelancerProfile(userId);
      if (!profile) {
        return res.status(400).json({ message: "Profile required for testing" });
      }

      const result = await proposalTestingService.testSpecificProject(projectId, profile, customInstructions);
      
      if (!result) {
        return res.status(404).json({ message: "Test project not found" });
      }

      res.json(result);
    } catch (error) {
      console.error("Error testing specific project:", error);
      res.status(500).json({ message: "Failed to test specific project" });
    }
  });

  // Email service routes
  app.get('/api/email/config', isAuthenticated, async (req: any, res) => {
    try {
      const config = emailService.getConfiguration();
      res.json(config);
    } catch (error) {
      console.error("Error fetching email config:", error);
      res.status(500).json({ message: "Failed to fetch email configuration" });
    }
  });

  app.post('/api/email/test', isAuthenticated, async (req: any, res) => {
    try {
      const { testEmail } = req.body;
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const template = emailService.getWelcomeEmail(user.firstName || 'User');
      const success = await emailService.sendEmail(testEmail || user.email, template);
      
      res.json({ success, message: success ? 'Test email sent successfully' : 'Failed to send test email' });
    } catch (error) {
      console.error("Error sending test email:", error);
      res.status(500).json({ message: "Failed to send test email" });
    }
  });

  app.post('/api/email/test-connection', isAuthenticated, async (req: any, res) => {
    try {
      const isConnected = await emailService.testConnection();
      res.json({ connected: isConnected });
    } catch (error) {
      console.error("Error testing email connection:", error);
      res.status(500).json({ message: "Failed to test email connection" });
    }
  });

  // Enhanced proposal generation
  app.post('/api/proposals/generate-enhanced', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { projectId, customInstructions, projectType } = req.body;
      
      const projects = await storage.getProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      
      const profile = await storage.getFreelancerProfile(userId);
      
      const proposalResult = await generateProposal(project, profile, customInstructions, projectType);
      
      const proposal = await storage.createProposal({
        userId,
        projectId,
        content: proposalResult.content,
        bidAmount: proposalResult.bidAmount,
        proposedTimeline: proposalResult.timeline,
        isAutoGenerated: true,
        status: "pending"
      });
      
      res.json({
        ...proposal,
        confidence: proposalResult.confidence,
        keyPoints: proposalResult.keyPoints
      });
    } catch (error) {
      console.error("Error generating enhanced proposal:", error);
      res.status(500).json({ message: "Failed to generate enhanced proposal" });
         }
   });

  // Performance and health monitoring routes
  app.get('/api/health', async (req, res) => {
    try {
      const healthCheck = performanceOptimizer.getHealthCheck();
      res.json(healthCheck);
    } catch (error) {
      console.error("Error in health check:", error);
      res.status(500).json({ 
        status: 'critical', 
        message: "Health check failed",
        error: (error as Error).message 
      });
    }
  });

  app.get('/api/performance/analytics', isAuthenticated, async (req: any, res) => {
    try {
      const analytics = performanceOptimizer.getPerformanceAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching performance analytics:", error);
      res.status(500).json({ message: "Failed to fetch performance analytics" });
    }
  });

  app.get('/api/performance/optimizations', isAuthenticated, async (req: any, res) => {
    try {
      const optimizations = performanceOptimizer.getFrontendOptimizations();
      res.json(optimizations);
    } catch (error) {
      console.error("Error fetching optimization recommendations:", error);
      res.status(500).json({ message: "Failed to fetch optimization recommendations" });
    }
  });

  app.post('/api/performance/clear-cache', isAuthenticated, async (req: any, res) => {
    try {
      const { pattern } = req.body;
      performanceOptimizer.clearCache(pattern);
      res.json({ message: "Cache cleared successfully" });
    } catch (error) {
      console.error("Error clearing cache:", error);
      res.status(500).json({ message: "Failed to clear cache" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
